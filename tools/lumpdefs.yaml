# OHRRPGCE data type definitions
# ===============================
#
# Conventions
# ~~~~~~~~~~~
#
# * minimize comments
# * maximize explicitness
#
---
# attic

__attic:
   animproposition1: &animproposition1
      _templating:
        '(type)': [hero, npc, enemy, weapon, attack, textbox, portrait, backdrop, tileset]
      # I'd like to note at this point that eventually migrating the basic lumping system
      # to ZIP would simplify a number of things.
      # I use sublumping here to work around lack of directory support in lump system.
      #
      # at CUSTOM runtime it seems appropriate to unflatten the sublumps
      # into a directory structure
      # myrpgdir/herogfx_bin/24/2.png    <- frame #2 in hero gfxset #24
      # myrpgdir/heroanim_bin/24.bin  <- hero animation #24
      #
      # for GAME runtime, partial unflattening:
      # myrpgdir/herogfx_bin/24.bin <- lumped file containing all frames in set #24
      #                                (preferably in strict numerical order,
      #                                 or alternatively in order of frequency of use)
      # myrpgdir/heroanim_bin/24.bin  <- hero animation #24
      #
      (type)gfx.bin:
         type: sublumped
         # in the case of tilesets and textboxes,
         # one gfxset == one tileset/textboxset,
         # stored as a *SINGLE IMAGE*.
         lumpnametemplate: ['%d.bin', gfxset_index]
         lump :
            type: sublumped
            lumpnametemplate: ['%d.bin', frame_index]
            lump:
               # named after frameindex. Tilesets and textboxsets only include #0
               # source fname for im/export
               # source rect if source fname is set
               # if no rect, entire picture is implied
               # W/H don't have to match the below w/h if they're set.
               src:
                  filename:
                     length: int16
                     content: [char (length), {if: length != 0}]
                  x: [int16, NULL, {if: filename.length != 0}]
                  y: [int16, NULL, {if: filename.length != 0}]
                  w: [int16, NULL, {if: filename.length != 0}]
                  h: [int16, NULL, {if: filename.length != 0}]
               #the following is mysteriously bad YAML
               #alette:
                  masterpalette : int16
                  # index of master palette that indices reference
                  # negative values may in the future
                  # represent non-paletted formats.
                  # exponential notation? 0= 1, 1= 2, 2 = 4, .. 8 = 256
                  length: [uint8,NULL,{if: masterpalette > -1}]
                  indices: [uint8, length, {if: masterpalette > -1}]
               d: int16 # depth, in the sense of z-axis. multi parts eg tiles in a tileset.
               w: int16
               h: int16
               img: [uint8, [n, h, w]] # undefined when palette.masterpalette < 0
               _repeats_for : NFRAMES
            _repeats_for : NSETS
      (type)anim.bin:
         type : sublumped
         # note: there should be no textboxanim.bin
         # animset 5 corresponds to gfxset 5
         lumpnametemplate: ['%d.reld', animset_index]
         lump :
            type : RELOAD
            reload:
               _runtime_state:
                  # when an animation is running:
                  anim: pointer
                  animindex: int16
                  animset: int16 #doesn't have to match gfxset
                  gfxtype: [enum, hero npc enemy weapon attack portrait backdrop tile]
                  gfxset : int16
                  frameindex : int16
                  frameindexbase : int16 # default = 0
                  frameindexmax : int16 # default = maxframe
                  # offsets relative to base bound-box top left corner
                  offsetx: int16
                  offsety: int16
                  wait: int16
                  paletteindex : int16
                  ctr : [uint8, 4]
                  index : uint16
                  sprite : pointer

                  _dontsave : anim sprite
                  _totalsize : 36 ?[64bit ptr]+ 8 bytes

               '%d':
                  name: string
                  tag2ctr: [int16, 4] # set ctr[i] = 1 if (tagexpr is true)
                  defaultwait: int16
                  code:
                     - blob (of opcode, (param, param..) bytecode sequences)
                     - oneop: # OP = int8. param = int8 or int16
                         - frame F Wa   # change to frame F in cur gfxset
                                        # if F > maxframe: F = 0
                                        #
                                        # if W == 0:
                                        #     wait (defaultwait)
                                        # else:
                                        #     wait (W)
                         - relframe Fo  # add Fo to current frame num.
                                        # wraps at ends, ie:
                                        # if curframe > maxframe or curframe < 0:
                                        #     curframe = curframe MOD maxframe
                                        # then wait (defaultwait)
                         - framerange F Le # Relativizes frame indexing
                                        # to a subrange of the total frames.
                                        # Invalidates current frame index.
                                        #
                                        # often immediately precedes an 'end'
                                        # op which chains to a simple animation pattern
                                        # eg.
                         - wait Tk      # wait n ticks
                                        # note : wait 0 is the canonical no-op.
                         - label Lb     # mark position of label n
                                        # no-op. this is purely data,
                                        # used by goto
                                        #
                                        # artificial, intentional limitation:
                                        # n < 256  to avoid vast insanities
                         - goto Lb      # goto label n
                                        # search from animation start for label n
                         - align Rel    # align relative to border (enum U,L,D,R, or Center)
                                        # offsets the image to match the bounding box.
                                        #
                                        # default is D (align bottom edges, center horizontally)
                                        #
                                        # 'sticky': following frames are also aligned in this
                                        # way.
                         - bbox x1 y1 x2 y2 # adjust the bounding box
                                            # *relative to current bbox*
                                            # that is, all parameters are offsets.
                                            #
                                            # initial bbox is dependent on gfx type
                         - offset Ox Oy # adjust display offset
                                        # as a relative offset from current offset
                                        #
                                        # overall offset is measured
                                        #  relative to top left of bounding box.
                         # gfxset is not modifyable by an animation.
                         - editpal Do Le I,I,.. # replace Le indices in the palette
                                                # @ Do offset.
                                                # All arguments are unsigned bytes.
                                                # CONSTRAIN (Le <= 256)
                                                # CONSTRAIN (0 <= Do < 256)
                                                # CONSTRAIN (Do + Le <=255)
                                                # I are a (Le)-some.
                                                # (indices into the master palette for this gfx
                                                # type.)
                         - cyclepal Le Do O # cycle part of the palette
                                            #  Le as for editpal,
                                            #     except source palette is
                                            #     the current sprite palette
                                            #  Do as for editpal
                                            #  O is an offset.
                                            #  O = 0: no-op
                                            #  O < 0: cycle forwards
                                            #  O < 1: cycle backwards
                                            #
                                            # runtime note: The simplest
                                            # implementation requires a
                                            # palette buffer
                                            # (copy the range of sprpal colors
                                            #  to buffer,
                                            #  then copy two parts from
                                            #  buffer to range in sprpal)
                         - loop Ct Lb   # setctr(Ct, -1); checkctr (Ct); goto (Lb);
                         - checkctr Ct  # check a counter != 0
                                        # n <= 3
                                        # if ctr[n] != 0:
                                        #    execute following operation
                                        # else:
                                        #    skip following operation
                         - setctr Ct n  # set counter to =n (when n >=0)
                                        # or subtract -n (when n <0)
                                        #       -- ie add n, which just happens
                                        #          to be negative.
                         - reset        # set palette = -1,
                                        # offset = [0,0]
                                        # bbox = default for this class of gfx.
                                        # frame is currently undefined.
                         - end Ast Nxt  # unconditional end of anim
                                        # Ast >= 0, Nxt != '':
                                        #     chain to anim #(Nxt) in animset Ast
                                        # Ast = -1, Nxt != '':
                                        #     chain to anim #(Nxt) in current animset)
                                        # Ast < -1, or Nxt = '':
                                        #     End without chaining
                                        #
                                        # not needed at natural end of animation.
                                        # Used in conjunction with conditional execution.



         # animation patterns and goto+wait, gotorel+wait should be implemented as a layer
         # over this.

# Data Definition
# ~~~~~~~~~~~~~~~~
#
__datadef:
   #lojban translations, for fun
   jbofanva:
      dtype: rejytai
      fields: rejme'e
      dtypes: rorejytai
      palette: skapoi
      enemy: fapro
      picture: pixra
      graphic : pixra
      sprite : klixra
      attack : nungunta
      spell : makru'e
      index : rejmoi
      owner : ponse
      doors : vorme
      doorlinks : vrojo'e
      requires : nitcu
      planar : plita
      part : pagbu
      shape : cimdytai
      map : cartu
      maplayer : catsenta
      song : sanga
      tag : tcita
      max : VALSIrai
   ATTRNAME: (str matching '[a-z][a-z0-9_]+')
   DESCRIPTION: (str)
   DTYPE: ['dtypeid (str)', 'range (list[2] or false)?', 'default ()?','extra (dict)']
   FIELDLIST: (str, ' '/'\n' separated)
   RANGE: [min (int), max (int)]
   BITSETDEF: '[ATTRNAME, DESCRIPTION] +'
   ENUMDEF:
            'dtype' : DTYPE
            (EXPRESSION) : FORMATSTRING +
   PREDEF:
            (name): DTYPE | RANGE ||
            'ENUMERATIONS': (map(:ENUMDEF+)) ||
            'BITSETS': (map(:BITSETDEF+))
   COMPLEX_DTYPE:
      #name_regex : '[a-z][a-z0-9_]+'
      #type : map
      dtype: (DTYPE|COMPLEX_DTYPE)
             exists XOR dtypes/fields existing
      dtypes : {FIELDNAME : (DTYPE|COMPLEX_DTYPE)+}
      fields : FIELDLIST
      default : seq
                a (possibly nested) sequence sufficient to initialize the
                whole struct to defaults.
                Useful for eg, master palette.
      flags:
         REQUIRED:
            Necessary to make sense of the RPG.
            if the lump is missing, it suggests a bad RPG.
         MANUALFLUSH:
            Changes won't be written to disk
            until the data handle is garbage-collected,
            or manual call of flush()
         PLANAR:
            Use a planar (AAABBBCCC) rather than
            atomic (ABCABCABC) data layout
            Requires -- all dtypes of same size,
            explicit shape.

         #alldtype:
         #   type: DTYPE | COMPLEX_DTYPE
         #   desc: Assign the given dtype to all fields
         #         which have not already had a dtype assigned
         # use a '*' field instead
         #defaults:
         #   type: seq
         #   desc: default values for all specified fields, in order.
         #         expressions are permitted.
      index:
         type: str (EXPRESSION)
         desc: start index (evaluated each time a lump handle is requested).
               Usually used with a multi-item lump like DOX
      part:
         type: seq (index (int), destdtype (str))
         desc: dtype describes a partial data, which should
               be concatenated with others to produce
               a final result. Intended specifically for
               ATTACK.BIN.
         requires: MANUALFLUSH in flags
      owner:
         type : str (EXPRESSION)
         desc : What to attach attribute to
      shape:
         type: seq (int+) | int
         desc: As in numpy.
               Used to specify partial slices of larger lumps, mostly.
   ROOTKEY:  COMPLEX_DTYPE | PREDEF
#
########################################################
##
#
## #
##########  Predefinition of limits, building blocks.
## #
#
##

######
# Note : Writing is NOT SUPPORTED for RPGFiles, only RPGDirs.
#        I decided this because RELOAD lumps and some others
#        require a complete rewrite, maybe altering file size.
#
BLOADO: &BLOADO 7
SHORT: &SHORT int16
MINSHORT: &MINSHORT -32768
MAXSHORT: &MAXSHORT 32767
USHORT : &USHORT uint16
MAXUSHORT: &MAXUSHORT 65535
UBYTE : &UBYTE uint8
MAXUBYTE : &MAXUBYTE 255
B6R : &B6R [0, 63]
B8R : &B8R [0, 255]
SHORTR : &SHORTR [*MINSHORT, *MAXSHORT]
USHORTR : &USHORTR [0, *MAXUSHORT]
ALLSHORT: &ALLSHORT {dtypes : {'*' : [*SHORT, *SHORTR, 0]}}
MAXHERO: &MAXHERO 60
HEROR : &HEROR [-60, 60]
MAXSHOP : &MAXSHOP 99
MAXSHOPITEMS : &MAXSHOPITEMS 50
MAXITEM : &MAXITEM 32000
ITEMR : &ITEMR [-32000, 32000]
MAXONETIMENPC : &MAXONETIMENPC 1000
MAXGFX : &MAXGFX 32767
MAXBG : &MAXBG 32767
MAXTILESET : &MAXTILESET 32767
MAX16PAL : &MAX16PAL 32767
MAX256PAL : &MAX256PAL 32767
MAXMAP : &MAXMAP 32767
MAXMAPLAYER : &MAXMAPLAYERS 7
MAXSONG : &MAXSONG 32767
MAXSFX : &MAXSFX 32767
MAXNPC : &MAXNPC 100
MAXNPCINSTANCE : &MAXNPCINSTANCE 300
MAXDOOR : &MAXDOOR 100
MAXDOORLINK : &MAXDOORLINK 200
MAXATTACK : &MAXATTACK 32767
ATTACKR : &ATTACKR [0, *MAXATTACK]
MAXENEMY : &MAXENEMY 32767
MAXFORMATION : &MAXFORMATION 32767
MAXFORMATIONSET : &MAXFORMATIONSET 32767
MAXSPELLLIST : &MAXSPELLLIST 4
MAXSPELLS : &MAXSPELLS 24
MAXVEHICLE : &MAXVEHICLE 32767
MAXSCRIPT : &MAXSCRIPT 32767
TAGR : &TAGR [-1000, 1000]
SCRIPTR : &SCRIPTR [*MINSHORT, *MAXSHORT]
MAXTAG : &MAXTAG 1000
MAXMONEY : &MAXMONEY 2000000000
NELEMENTS : &NELEMENTS 8
NSTATS : &NSTATS 12

PERCENTR: &PERCENTR [0, 100]
SHORTITEM: &SHORTITEM
   - *SHORT
   - [0, *MAXITEM]
   - 0
   - wasted: 1b
     unsigned: yes
SHORTPERCENT: &SHORTPERCENT
   - *SHORT
   - *PERCENTR
   - 0
   - wasted: 9b
     unsigned: yes
SHORTTYPE: &SHORTTYPE [*SHORT, *SHORTR, 0]
CLASS_DTYPE : &CLASS_DTYPE
   __class : dtype
CLASS_ENUM : &CLASS_ENUM
   __class : enum

PTMERGE : &PTMERGE
   << : *CLASS_DTYPE
   dtype : [uint8, [0, *MAXUBYTE], 0]
   flags : PACKED4BPP IMAGE
   owner : rpg.gfx
DEFPALMERGE: &DEFPALMERGE
   << : *CLASS_DTYPE
   owner: rpg.defpal
   dtype : [*SHORT, [0, *MAX16PAL], 0]
   softrange : rpg.pal16 # limited to len (rpg.pal16)

RPGOWNED: &RPGOWNED
   owner : RPG

TEXTLINE : &TEXTLINE "%s\n"

RGB6: &RGB6 # used or not?
   << : *CLASS_DTYPE
   fields: r g b
   dtypes: {'*' : [uint8, *B6R, 0, {wasted: 2bits}]}

RGB8: &RGB8
   << : *CLASS_DTYPE
   fields : r g b
   dtypes : {'*' : [uint8, *B8R, 0]}

RGB6W: &RGB6W
   << : *CLASS_DTYPE
   fields : r g b
   dtypes : {'*' : [*USHORT, *B6R, 0, {wasted: 10bits}]}

XYCOORD: &XYCOORD
   << : [*CLASS_DTYPE, *ALLSHORT]
   fields : x y

STATS: &STATS
   << : [*CLASS_DTYPE, *ALLSHORT]
   fields : hp mp str acc def dog mag wil spd ctr foc xhits

STATS0_99: &STATS0_99
   << : *CLASS_DTYPE
   fields : hp mp str acc def dog mag wil spd ctr foc xhits
   dtypes : {'*'   : [[*SHORT, 2], *SHORTR, 0]}

# dtype :
#   << : *CLASS_DTYPE
#   dtype: {[*STTENTRY, 0-3], no, 'default string}
#

STTENTRY1: &STTENTRY1
   - fields : length data
     dtypes :
        length : [uint8, [0,10], 0]
        data : [S10, no, '']
     shape: 1
   - no
   - {automangle: str}
STTENTRY2: &STTENTRY2
   << : *CLASS_DTYPE
   dtype :
     - fields : length data
       dtypes :
          length : [uint8, [0,10], 0]
          data : [S10, no, '']
       shape: 2
     - no
     - {automangle: str}
STTENTRY3: &STTENTRY3
   << : *CLASS_DTYPE
   dtype :
     - fields : length data
       dtypes :
          length : [uint8, [0,10], 0]
          data : [S10, no, '']
       shape: 3
     - no
     - {automangle: str}
##
#
## #
##########  Bitsets, enumerations and related weird variants
## #
#
##

BITSETS:
   BGENERAL: &BGENERAL
      - [         pause_on_submenus, Pause on battle sub-menus]
      - [               caterpillar, Enable caterpillar party]
      - [               norestorehp, Don't restore HP on levelup]
      - [               norestoremp, Don't restore MP on levelup]
      - [              inn_norevive, Inns don't revive dead heroes]
      - [       always_heroswapping, Hero swapping always available]
      - [          battle_hideready, Hide ready-meter in battle]
      - [         battle_hidehealth, Hide health-meter in battle]

      - [                   nodebug, Disable debugging keys]
      - [               levelup_bug, Simulate old levelup bug]
      - [          doubletrigger_ok, Permit double-triggering of scripts]
      - [                 skiptitle, Skip title screen]
      - [                  skipload, Skip load screen]
      - [        pause_on_all_menus, Pause on all battle menus]
      - [           no_battlecursor, Disable hero's battle cursor]
      - [                no_defpass, Default passability disabled by default]
      # 8 remain
   BGENSUSPEND: &BGENSUSPEND
      - [npcs, NPCs]
      - [player, Player]
      - [obstruction, Obstruction]
      - [herowall, Hero Walls]
      - [npcwall, NPC Walls]
      - [catapillar, Catapillar]
      - [randenemy, Random Enemies]
      - [boxadv, Box Advance]
      - [overlay, Overlay]
      - [ambmusic, Ambient Music]
   BGENERAL2: &BGENERAL2
      - [               npcpush_bug, Simulate pushable NPC obstruction bug]
      - [           disable_esc_run, Disable ESC key running from battle]
      - [ nosave_special_script_ids, Don't save gameover/loadgame script IDs]
      - [          deadheros_getexp, Dead heroes gain share of experience]
      - [     lock_stops_reordering, Locked heroes can't be re-ordered]
      - [     captions_pause_battle, Attack captions pause battle meters]
      - [no_randomize_battle_meters, Don't randomize battle ready meters]
      - [    menus_wait_attackanims, Battle menus wait for attack animations]
   BFIXBITS: &BFIXBITS
      # 0
      - [attack_items, Zeroed out item cost (ammunition) data in ATTACK.BIN]
      - [weapon_points, Fixed hero hand positions in DT0]
      - [stun_cancel_targ, Turned on "Cancel Target's Attack" bit in ATTACK.BIN for old attacks that damage the Stun register]
      - [default_dissolve, Initialized genEnemyDissolve to default in GEN]
      - [default_dissolve_enemy, Initialized Enemy dissolves to default in DT1]
      - [pushnpc_bugcompat, Turned on the Simulate pushable NPC obstruction bug bitset]
      - [default_maxitem, Stored default max item number from ITM in GEN]
      - [blank_doorlinks, Marked redundant blank doorlinks as unused]
      # 8
      - [shop_sounds, Initialized all the sound effects from gen.itemlearnsfx to gen.cantsellsfx (to one of gen.acceptsfx or gen.cancelsfx))]
      - [extended_npcs, Initialized all blank NPC data in the empty space at the end of .N## lumps]
      - [hero_portrait, Initialized Hero portrait data]
      - [textbox_portrait, Initialized text box portrait data]
      - [npclocation_format, Converted NPC locations to new format (FIXME: not implemented yet)]
      - [init_damagedisplay, Initialize default values for damage display time and distance in GEN]
      # 14 (2 remain)
   BMENUITEM: &BMENUITEM
      - [hide_when_disabled, Hide when disabled]
      - [        close_menu, Close menu when selected]
      - [        no_onclose, Don't run on-close script]
      # 5 remain
   BTEXTBOX : &BTEXTBOX
      - [   choicebox, Enable choicebox]
      - [       nobox, Disable box]
      - [     notrans, Disable translucency]
      - [restoremusic, Enable restore music]
      - [ portraitbox, Show a box around portrait]
      - [     stopsfx, Stop sound FX when box advances]
      # 2 unused
   BSHOP : &BSHOP
      - [  buy, Buy]
      - [ sell, Sell]
      - [ hire, Hire]
      - [  inn, Inn]
      - [equip, Equip]
      - [ save, Save]
      - [  map, Map]
      - [ team, Team]
      # 8 unused
   BATTACKCHAIN : &BATTACKCHAIN
      - [    mustknow, Attacker must know chained attack]
      - [ ignoredelay, Ignore chained attack's delay]
      - [ nonblocking, Chained attack doesn't block actions]
      # 5+8 = 13 unused
   BENEMY : &BENEMY
      - - += [(v[0][:v[0].find(' ')].lower() + 'elem' + v[-2], ''.join (v))
              for v in itertools.product(('Weak vs ','Strong vs ','Absorbs '),
                                         ('$rpg.strings.element[',),
                                         [str(v) for v in range (8)],(']',))]
      - - += [('type%d' % v,
               'Enemy type $rpg.strings.enemytype[%d]' % v)
              for v in range (8)]
      - - += [('unused%d' % v, 'Unused %d' % v) for v in range(22)]
      - [        cureharms, Harmed by cure]
      - [          mpidiot, MP Idiot]
      - [             boss, Boss]
      - [      unescapable, Unescapable]
      - [        diewoboss, Die without boss]
      - [       fleenotdie, Flee instead of die]
      - [  no_enemy_target, Untargetable by enemies]
      - [   no_hero_target, Untargetable by heros]
      - [win_even_if_alive, Win battle even if left alive]
      - [         noflinch, Never flinch when hit]
      - [     alone_ignore, Ignored by 'Alone' AI]
      - - += [('unused%d' % (v+22), 'Unused %d' % (v+22)) for v in range(15)]
   BDOORS : &BDOORS
      - [ used, Used]
   BPASS : &BPASS
      - [ north, Block north]
      - [ east, Block east]
      - [ south, Block south]
      - [ west, Block west]
      - [ veha, Vehicle A]
      - [ vehb, Vehicle B]
      - [ harm, Harm tile]
      - [ over, Overhead tile]

ENUMERATIONS:
   ETAGCHECK: &ETAGCHECK
      flags : ENUM
      dtype : [*SHORT, *TAGR, 0]
      enumdepends : N rpg.tagname
      0+ : ['tag${N}_on', 'Tag ${N} (${rpg.tagname.get(N)}) == ON']
      -1[: ['tag${-N}_off', 'Tag ${-N} (${rpg.tagname.get(-N)}) == OFF']
   ETAGSET: &ETAGSET
      flags : ENUM
      dtype : [*SHORT, *TAGR, 0]
      enumdepends : N rpg.tagname
      0+ : ['tag${N}_on', 'Tag ${N} (${rpg.tagname.get(N)}) = ON']
      -1[: ['tag${-N}_off', 'Tag ${-N} (${rpg.tagname.get(-N)}) = OFF']
   EHERO_SPELLLIST : &EHERO_SPELLLIST
      flags : ENUM
      dtype : [*SHORT, [0, 3], 0]
      0 : [spells_mp, Spells (MP Based)]
      1 : [spells_levelmp, Spells (FF1 Style)]
      2 : [random, Random Effects]
      3 : [item, Item Consuming]
   ENPC_MOVETYPE : &ENPC_MOVETYPE
      flags : ENUM
      dtype : [*SHORT, [0, 8], 0]
      0 : [standstill, Stand still]
      1 : [    wander, Wander]
      2 : [      pace, Pace]
      3 : [ rightturn, Right turns]
      4 : [  leftturn, Left turns]
      5 : [randomturn, Random turns]
      6 : [     chase, Chase you]
      7 : [     avoid, Avoid you]
      8 : [   inplace, Walk in place]
   ENPC_SPEED : &ENPC_SPEED
      flags : ENUM
      dtype : [*SHORT, [0, 5], 0]
      0 : [0, '0']
      1 : [1, '1']
      2 : [2, '2']
      3 : [10, '3']
      4 : [4, '4']
      5 : [5, '5']
   ENPC_ACTIVATED : &ENPC_ACTIVATED
      flags : ENUM
      dtype : [*SHORT, [0, 2], 0]
      0 : [     changedir, Change Direction]
      1 : [    faceplayer, Face Player]
      2 : [dontfaceplayer, Do Not Face Player]
   ENPC_PUSHABILITY : &ENPC_PUSHABILITY
      flags : ENUM
      dtype : [*SHORT, [0, 7], 0]
      0 : [       off, 'Off']
      1 : [      full, Full]
      2 : [horizontal, Horizontal]
      3 : [  vertical, Vertical]
      4 : [        up, Up Only]
      5 : [     right, Right Only]
      6 : [      down, Down Only]
      7 : [      left, Left Only]
   ENPC_ACTIVATION : &ENPC_ACTIVATION
      flags : ENUM
      dtype : [*SHORT, [0, 2], 0]
      0 : [   use, Use]
      1 : [ touch, Touch]
      2 : [stepon, Step On]
   EPORTRAITTYPE : &EPORTRAITTYPE
      flags : ENUM
      dtype : [*SHORT, [0, 3], 0]
      0 : [none, 'None']
      1 : [fixed, Fixed]
      2 : [hero_caterpiller, Hero By Caterpillar]
      3 : [hero_slot, Hero By Party Slot]
   ETEXTBOX_BOXORSCRIPT : &ETEXTBOX_BOXORSCRIPT
      flags : ENUM
      dtype : [*SHORT, *SCRIPTR, 0]
      enumdepends : N rpg.triggers rpg.general rpg.scripts
      0[ : [textbox$(N), Textbox $(N)]
      -(min (16384, rpg.general.maxplotscript)),0 :
            ['script${-N}', 'Run script ${-N} ($(rpg.scripts[-N]))']
      -(16384 + len (rpg.triggers)),<-16384 :
            ['trigger${-(N+16384)}', 'Trigger ${-(N+16384)} (${getstr (rpg.general.triggers[-(N+16384)].name)))']
   ESHOPORINN : &ESHOPORINN
      flags : ENUM
      enumdepends : N rpg.shops rpg.strings rpg.general
      dtype : [*SHORT, [*MINSHORT, rpg.general.maxshop], 0]
      0   : [restore, Restore HP/MP]
      1[  : ['shop${N}', 'Enter Shop ${N} ${getstr (rpg.shops[N].name)}']
      -1] : [ 'inn${-N}', 'Enter Inn Costing ${getstr (rpg.strings.money)+str(-N)}']
   EADDHERO : &EADDHERO
      flags : ENUM
      enumdepends : N rpg.general rpg.hero
      dtype : [*SHORT, [-rpg.general.maxhero, rpg.general.maxhero], 0]
      0   : [     nothing, Do Not Add/Remove Heros]
      1[  : [   'add${N}', 'Add Hero ${N} (${getstr(rpg.hero[N].name)}) To The Party']
      -1] : ['remove${-N}', 'Remove Hero ${-N} (${getstr(rpg.hero[-N].name)}) From The Party']
   EADDITEM : &EADDITEM
      flags : ENUM
      enumdepends : N rpg.general rpg.hero
      dtype : [*SHORT, [-rpg.general.maxitem, rpg.general.maxitem], 0]
      0   : [nothing, Do Not Add/Remove Items]
      1[  : [    'add${N}', 'Add Item ${N} (${getstr(rpg.item[N].name)}) To Inventory']
      -1] : ['remove${-N}', 'Remove Item ${-N} (${getstr(rpg.item[-N].name)}) From Inventory']
   ESWAPHERO : &ESWAPHERO
      flags : ENUM
      enumdepends : N rpg.general rpg.hero
      dtype : [*SHORT, [-rpg.general.maxhero, rpg.general.maxhero], 0]
      0   : [nothing, Do Not Swap In/Out Heros]
      1[  : [   'add${N}', 'Swap Hero ${N} (${getstr(rpg.hero[N].name)}) In']
      -1] : ['remove${N}', 'Swap Hero ${N} (${getstr(rpg.hero[-N].name)}) Out']
   ELOCKHERO : &ELOCKHERO
      flags : ENUM
      enumdepends : N rpg.general rpg.hero
      dtype : [*SHORT, [-rpg.general.maxhero, rpg.general.maxhero], 0]
      0   : [nothing, Do Not Lock/Unlock Heros]
      1[  : [   'add${N}', 'Unlock Hero ${N} (${getstr(rpg.hero[N].name)})']
      -1] : ['remove${N}', 'Lock Hero ${N} (${getstr(rpg.hero[-N].name)})']
   EENEMYTHIEVABLE : &EENEMYTHIEVABLE
      flags : ENUM
      dtype : [*SHORT, [-1, 1], 0]
      -1 : Not thievable
      0 : Once only
      1 : Infinitely thievable
   EPICSIZE : &EPICSIZE
      flags : ENUM
      dtype : [*SHORT, [0, 2], 0]
      0 : Small
      1 : Medium
      2 : Large
   EENEMYDISSOLVE : &EENEMYDISSOLVE
      flags : ENUM
      dtype : [*SHORT, [0, 8], 0]
      0 : (NONE SET)
      1 : Random scatter
      2 : Crossfade
      3 : Diagonal vanish
      4 : Sink into ground
      5 : Squash
      6 : Melt
      7 : Vapourise
      8 : Phase out
   EENEMYDISSOLVELEN : &EENEMYDISSOLVELEN
      flags : ENUM
      dtype : [*SHORT, [0, 99], 0]
      0 : default

__STATUS:
   # 1 == seems complete, 2 == tested, 3 == well tested, 4 == used in app
   archinym.lmp: 1
   browse.txt  : 1
   gen         : .99
   attack.bin  : no
   binsize.bin : 1
   defpal?.bin : 1
   defpass.bin : 1
   fixbits.bin : no
   lookup1.bin : 1
   menus.bin   : no
   menuitem.bin: 1
   palettes.bin: 1
   plotscr.lst : no
   sfxdata.bin : no
   songdata.bin: no
   uicolors.bin: no
   slicetree_?_?.reld: no
   bam         : no
   t           : no
   p           : no
   e           : no
   d           : no
   l           : no
   n           : no
   z           : no
   dor         : no
   dox         : 1
   dt0         : no
   dt1         : 1
   dt6         : no
   efs         : no
   for         : no
   fnt         : no
   hsp         : no
   hsz         : no
   itm         : no
   map         : no
   mas         : 1
   mn          : no
   mxs         : 1
   pal         : 1
   pt?         : 1
   say         : 1
   sho         : 1
   stf         : no
   stt         : no
   tap         : no
   til         : 1
   tmn         : 1
   veh         : no



##
#
## #
##########  Actual lump definitions
## #
#
##
archinym.lmp:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname : archinym
   fields : [prefix version, {}]
   defaults : [$rpgprefix, nohrio version $nohrioversion]
   hdf5_transform :
      - attribute_transform (src, path = '/', prefix = editor_)
                              # prefix, version
                              # <-> attributes attached to /
                              # named editor_(prefix|version)
   yaml_transform :
      - keymap (src)
      - keyunmap (src)
   loadpriority : 1
   flags:
      - REQUIRED
      - FULL_REWRITE_ON_CHANGE
      - SINGULAR
   alldtype: *TEXTLINE
attack.bin:
   << : *CLASS_DTYPE
   #XXX
binsize.bin:
   << : *CLASS_DTYPE
   attrname : binsize
   fields : attack stf songdata sfxdata map menu menuitem uicolor say npcdef
   dtypes : {'*' : [*SHORT, *SHORTR, 0]}
   flags :
      - BASE
      - AUTOSIZE
      - SINGULAR
   hdf5_transform :

      # atomic_copy def:
      #
      #   dest = h.createEArray(pathpart,
      #                         namepart,
      #                         tables.Atom.from_dtype (dtype),
      #                         shape = (0,),
      #                         expectedrows = len (arr) * 2)
      #   dest.append (arr.view(dtype))
      #   if arr.names:
      #       dest.fieldnames = self.dtype.names
      #
      #   return dest
      - tmp = atomic_copy (self, uint16, h5, path = '/redundant/binsize')
        tmp.fieldnames = self.dtype.names
        return tmp
      # earray_to_numpy def:
      #
      #   dt = node.atom.dtype
      #   names = node.fieldnames
      #   dtype = np.dtype ([(n, dt) for n in names])
      #   return node[:].astype (dtype)
      #
      - return earray_to_numpy (h5.root.redundant.binsize)
   yaml_transform :
      - keymap (src)
      - keyunmap (src, dtype)
browse.txt:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname: browse
   fields: longname about
   dtypes:
      '*': [=str16_8, 38]
   yaml_transform:
      - keymap (src)
      - keyunmap (src, dtype)
d:
   << : *CLASS_DTYPE
   owner : Map
   attrname : doorlinks
   fields : srcdoor destdoor destmap condtag1 condtag2
   dtypes :
      '*' : [*SHORT, *SHORTR, 0]
      condtag1 : [*SHORT, *TAGR, 0]
      condtag2 : [*SHORT, *TAGR, 0]
   flags: PLANAR
          MAPINDEXED
   maplumpindex: $owner.n
   shape: 200
defpal0.bin:
   << : *DEFPALMERGE
   attrname: hero
   nameindex : pt0
defpal1.bin:
   << : *DEFPALMERGE
   attrname: enemy_smal
   nameindex : pt1
defpal2.bin:
   << : *DEFPALMERGE
   attrname: enemy_med
   nameindex : pt2
defpal3.bin:
   << : *DEFPALMERGE
   attrname: enemy_big
   nameindex : pt3
defpal4.bin:
   << : *DEFPALMERGE
   attrname: walk
   nameindex : pt4
defpal5.bin:
   << : *DEFPALMERGE
   attrname: weapon
   nameindex : pt5
defpal6.bin:
   << : *DEFPALMERGE
   attrname: attack
   nameindex : pt6
defpal7.bin:
   << : *DEFPALMERGE
   attrname: textbox
   nameindex : pt7
defpal8.bin:
   << : *DEFPALMERGE
   attrname: portrait
   nameindex : pt8
defpass.bin:
   owner : til
   index: [$owner.offset / $owner.itemsize]
   fields: pass magic
   dtypes:
      pass: [=bitsets, [16, *BPASS], 160]
      magic: [=magic, [4444, *SHORT]]
dt1:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname: enemy
   fields: name thievability steal_item steal_chance
           raresteal_item raresteal_chance dissolve dissolvelen
           deathsound battlecursor unused picture palette picsize rewards stats
           bitsets spawning attacks counter unused2
   dtypes :
      '*' : [*SHORT, *SHORTR, 0]
      name : [=str16_16, 16]
      thievability : *EENEMYTHIEVABLE
      steal_item: *SHORTITEM
      steal_chance: *SHORTPERCENT
      raresteal_item: *SHORTITEM
      raresteal_chance: *SHORTPERCENT
      dissolve : *EENEMYDISSOLVE
      dissolvelen : *EENEMYDISSOLVELEN
      battlecursor : [*XYCOORD, *SHORTR, [0,0]]
      unused : [[*SHORT, 26], *SHORTR, 0]
      picsize : *EPICSIZE
      rewards :
         fields : gold exp item item_chance rare_item rare_item_chance
         dtypes :
            '*' : [*SHORT, *SHORTR, 0]
            item: *SHORTITEM
            item_chance: *SHORTPERCENT
            rare_item: *SHORTITEM
            rare_item_chance: *SHORTPERCENT
            bitsets : [=bitsets, [80, *BENEMY]]
            stats : *STATS
            spawning:
               fields : death nonelem_death alone nonelem_hit elem_hit
                        nspawn
               dtypes:
                  '*' : [*SHORT, *SHORTR, 0]
                  elem_hit : [[*SHORT, *NELEMENTS], *SHORTR, ]
      attacks:
         fields : normal desperate alone
         dtypes : {'*' : [[*SHORT, 5], *ATTACKR, 0]}
      counter :
         fields: element stat
         dtypes:
            element : [[*SHORT, *NELEMENTS], *ATTACKR, 0]
            stat : [[*SHORT, *NSTATS], *ATTACKR, 0]
      unused2 : [[*SHORT, 33], *SHORTR, 0]
dox:
   << : *CLASS_DTYPE
   owner : Map
   attrname : doors
   fields : x y bitsets
   dtypes :
      '*' : [*SHORT, *SHORTR, 0]
      bitsets : *BDOORS
   flags: PLANAR
   index: [$owner.n]
   shape: 100
gen:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname : general
   flags : REQUIRED
           SINGULAR
   loadpriority : 2
   hook : checkpassword ($self.,$self.)
   offset : *BLOADO
   expected_size : 1007
   # field groups are used in the following:
   fields: # bighuge field list follows.
           maxmap(max) title(meta) titlemusic(snd) victorymusic(snd) battlemusic(snd)
           passcode_version(pwd) passcode_rotator(pwd) newpasscode(pwd) newpasscode_unused(pwd)
           oldpasscode(pwd)

           maxheropic(max) maxenemy1pic(max) maxenemy2pic(max) maxenemy3pic(max)
           maxnpcpic(max) maxweaponpic(max) maxattackpic(max)
           maxtileset(max) maxattack(max) maxhero(max) maxenemy(max)
           maxformation(max) maxpal16(max) maxtextbox(max) maxplotscript(max)

           newgamescript(scr) gameoverscript(scr,sav) max_regularscript(max)
           suspendbits(sav) cameramode(sav) camera_args(sav) scriptbackdrop(scr) time(sav)
           maxvehicle(max) maxtagname(max)
           loadgamescript(scr,sav) textbox_backdrop(gfx,sav) enemydissolve(gfx) enablejoy(sav)
           poison(gfx,sav) stun(gfx,sav) damagecap(sav) mute(gfx,sav) statcap(max)
           maxsfx(max) masterpal(gfx)

           maxmasterpal(max) maxmenu(max) maxmenuitem(max) maxitem(max) max_boxborder(max)
           maxportrait(max) maxinventory(max,sav)

           errorlevel(meta)
           reserved(xxx)

           oldpassword2_offset(pwd) oldpassword2_length(pwd) version(meta) startmoney(ini)
           maxshop(max) oldpassword1_offset(pwd) oldpassword1_length(pwd) maxbackdrop(max)
           bitsets(bts)

           startx(ini) starty(ini) startmap(ini)

           onetimenpc_indexer onetimenpc_bits
           def_deathsfx(sfx) maxsong(max) acceptsfx(sfx) cancelsfx(sfx) choosesfx(sfx) textboxlettersfx(sfx)
           morebitsets(bts) itemlearnsfx(sfx) cantlearnsfx(sfx) buysfx(sfx) hiresfx(sfx) sellsfx(sfx)
           cantbuysfx(sfx) cantsellsfx(sfx) damagedisplayticks(gfx) damagedisplayrise(gfx)
           wastedspace(xxx) oldsctable_head(pwd) oldsctable unused(pwd,xxx)
   dtypes:
      '*' : [*SHORT, *SHORTR, 0]
      bitsets : [=bitsets, [16, *BGENERAL]]
      newpasscode: [UBYTE, 17]
      newpasscode_unused: UBYTE
      oldpasscode: [*SHORT, 10]
      suspendbits: [=bitsets, [16, *BGENSUSPEND]]
      camera_args: [*SHORT, 4]
      time:
         fields: days hours minutes seconds
         dtypes: {'*' : [*SHORT, *SHORTR, 0]}
      statcap: [*SHORT, 12]
      reserved: [*SHORT, 6]
      onetimenpc_bits : [=rawbitsets, [1040]] # 130*8
      morebitsets : [=bitsets, [32, *BGENERAL2]]
      wastedspace: [*SHORT,11]
      oldsctable_head: uint16
      oldsctable: [uint16, 160]
      unused: [*SHORT, 140]

lookup1.bin:
   << : *CLASS_DTYPE
   attrname : triggers
   fields : id name
   dtypes:
      id : [*SHORT, [0, *MAXSCRIPT], 0]
      name: [[=str16_8, 36], no, [0, '']]
#XXX continue here
mas:
   << : *CLASS_DTYPE
   offset: *BLOADO
   flags: OBSOLETE AUTOUPGRADE
   upgrade: |
        if self.rpg.lump_exists('palettes.bin'):
            self.rpg.remove_lump ('mas')
            return
        # 6->8bpp transform
        bpp8 = take ([  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  45,  49,
                       53,  57,  61,  65,  69,  73,  77,  81,  85,  89,  93,  97, 101,
                      105, 109, 113, 117, 121, 125, 130, 134, 138, 142, 146, 150, 154,
                      158, 162, 166, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206,
                      210, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255], self)
        final = bpp8.astype ('B').view (dtypes['palettes.bin'])
        d = self.rpg.data ('palettes.bin', shape = 1)
        d[0] = final
        d.flush()
        del d
        self.rpg.remove_lump ('mas')
    # XXX
menuitem.bin:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname : menuitem
   fields :
            - membership caption sort_order type subtype tagcond1
              tagcond2 settag toggletag bitsets extra
            - extra : [*SHORT, 3]
              caption : [str16_8, 38]
              bitsets : [=bitsets, [16, *BMENUITEM]]
mxs: &mxs
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname: backdrop
   dtype : [uint8, [4, 200, 80]]
   linear_transform: |
      """Transform from a planar mode-x image into a conventional linear image"""
      tmp = np.array (shape = (200, src.shape[-1] * src.shape[0]), dtype = 'uint8')
      step = src.shape[0]
      for i in range (step):
          tmp[:,i::step] = src [i,:,:]
      return tmp

pal:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname: pal16
   dtype : [[uint8, 16], *B8R, 0]
   softdep: mas palettes.bin
palettes.bin :
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname: pal16
   dynamic_dtype : [*RGB8, '$header[1] / 3']
   dtype : [[*RGB8, 256], *B8R, [0,0,0]]
   header : [*SHORT, 2]
pt0:
   << : *PTMERGE
   attrname: hero
   shape: [8, 32, 20] # 20->40px
   soft_deps: defpal0.bin
pt1:
   << : *PTMERGE
   attrname: enemy_smal
   shape: [1, 34, 17] # 17->34px
   soft_deps: defpal1.bin
pt2:
   << : *PTMERGE
   attrname: enemy_med
   shape: [1, 50, 25] # 25->50px
   soft_deps: defpal2.bin
pt3:
   << : *PTMERGE
   attrname: enemy_big
   shape: [1, 80, 40] # 40->80px
   soft_deps: defpal3.bin
pt4:
   << : *PTMERGE
   attrname: walk
   shape: [8, 20, 10] # 10->20px
   soft_deps: defpal4.bin
pt5:
   << : *PTMERGE
   attrname : weapon
   shape: [2, 24, 12] # 12->24px
   soft_deps: defpal5.bin
pt6:
   << : *PTMERGE
   attrname : attack
   shape: [3, 50, 25] # 25->50px
   soft_deps: defpal6.bin
pt7:
   << : *PTMERGE
   attrname : textbox
   shape: [16, 16, 8] # 8->16px
   soft_deps: defpal7.bin
pt8:
   << : *PTMERGE
   attrname : portrait
   shape: [1, 50, 25] # 25->50px
   soft_deps: defpal8.bin

say:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname : textbox
   flags : BINSIZED
   fields :
            - text reserved1 conditional reserved2 bitsets
              choice1 wasted choice2 menuconditional verticalpos
              shrink textcolor bordercolor backdrop music menu
              portraittype portraitpic portraitpal portraitx portraity
              sound
            - << : *ALLSHORT
              text : [S38, 8]
              reserved1 : uint8
              conditional :
                 - fields :
                     - jumpto_instead settag fight inn hero1
                       jumpto_after money usedoor item hero2
                     - jumpto_instead:
                          fields:
                             - tagcheck param
                             - tagcheck : *ETAGCHECK
                               param : *ETEXTBOX_BOXORSCRIPT
                       settag:
                          fields:
                             - tagcheck tagsets
                             - tagcheck : *ETAGCHECK
                               tagsets  : [*ETAGSET, 2]
                       formation:
                          fields:
                             - tagcheck formation
                             - tagcheck  : *ETAGCHECK
                               formation : *SHORT
                       inn:
                          fields:
                             - tagcheck param
                             - tagcheck  : *ETAGCHECK
                               param : *ESHOPORINN
                     # XXX hero swap/un/lock FUBARness
                       hero1:
                          fields:
                             - tagcheck add
                             - tagcheck  : *ETAGCHECK
                               add : *EADDHERO
                       jumpto_after:
                          fields:
                             - tagcheck param
                             - tagcheck : *ETAGCHECK
                               param : *ETEXTBOX_BOXORSCRIPT
                       money:
                          fields:
                             - tagcheck amount
                             - tagcheck : *ETAGCHECK
                               amount : *SHORT
                       usedoor:
                          fields:
                             - tagcheck door
                             - tagcheck : *ETAGCHECK
                               amount : *SHORT
                       item:
                          fields:
                             - tagcheck item
                             - tagcheck : *ETAGCHECK
                               amount : *EADDITEM
                       hero2:
                          fields:
                             - swap lock
                             - swap : *ESWAPHERO
                               lock : *ELOCKHERO
              reserved2 : uint8
              bitsets : [=bitsets, [8, *BTEXTBOX]]
              choice1 :
                 fields :
                    - choice choice_tag
                    - text : [=str8_8, 15]
                      tag : *ETAGSET
              wasted : uint8
              choice2 :
                 fields :
                    - choice choice_tag
                    - text : [=str8_8, 15]
                      tag : *ETAGSET
              menuconditional : *ETAGCHECK
              portraitpal :
                 dtype : *SHORT
                 softrange : rpg.pal16

              portraittype : *EPORTRAITTYPE




              #XXX continue here
sho:
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname: shopinfo
   flags:
   fields:
           - name nitems bitsets inncost innscript
           - '*'   : *SHORT
             '*[]' : *SHORTR
             name      : [=str16_16, 16]
             nitems[]  : [-1,49]
             bitsets   : [=bitsets, [16, *BSHOP]]
             innscript : *SCRIPTR

stt:
   << : [*CLASS_DTYPE, *RPGOWNED]
   # output generated by stt2yaml
   fields: health_points spell_points attack_power accuracy extra_hits
           blocking_power dodge_rate counter_rate speed
           enemy_type_1 enemy_type_2 enemy_type_3 enemy_type_4
           enemy_type_5 enemy_type_6 enemy_type_7 enemy_type_8
           elemental_1 elemental_2 elemental_3 elemental_4
           elemental_5 elemental_6 elemental_7 elemental_8
           armor_1 armor_2 armor_3 armor_4
           spell_skill spell_block spell_cost_pc money experience
           item done autosort trash weapon _remove_ _exit_
           discard cannot level yes no exit
           for_next remove pay cancel cancel2 new_game exit2
           pause quit_playing_ yes2 no2 cancel3
           items spells status equip order team save quit map volume buy sell inn hire
           exit3 cannot_sell worth trade_for and_a worth_nothing sold
           trade_for2 joins_for cannot_afford cannot_hire purchased
           joined_ in_stock equip_ no_room_in_party replace_old_data_
           who_s_status_ who_s_spells_ equip_who_ nothing has_nothing
           cannot_steal stole miss fail learned found gained weak_to
           strong_to absorbs no_elemental_effects has_no_spells which_hero_
           name_the_hero found_a found2 the_inn_costs you_have cannot_run_
           level_up_for levels_for
           and day days hour hours minute minutes
           level_mp
   dtypes:

           - health_points        : *STTENTRY1
             health_points?       : [13, 'Health Poi']
             spell_points         : *STTENTRY1
             spell_points?        : [12, 'Spell Poin']
             attack_power         : *STTENTRY1
             attack_power?        : [12, 'Attack Pow']
             accuracy             : *STTENTRY1
             accuracy?            : [8, 'Accuracy']
             extra_hits           : *STTENTRY1
             extra_hits?          : [10, 'Extra Hits']
             blocking_power       : *STTENTRY1
             blocking_power?      : [14, 'Blocking P']
             dodge_rate           : *STTENTRY1
             dodge_rate?          : [10, 'Dodge Rate']
             counter_rate         : *STTENTRY1
             counter_rate?        : [12, 'Counter Ra']
             speed                : *STTENTRY1
             speed?               : [5, 'Speed']
             enemy_type_1         : *STTENTRY1
             enemy_type_1?        : [12, 'Enemy Type']
             enemy_type_2         : *STTENTRY1
             enemy_type_2?        : [12, 'Enemy Type']
             enemy_type_3         : *STTENTRY1
             enemy_type_3?        : [12, 'Enemy Type']
             enemy_type_4         : *STTENTRY1
             enemy_type_4?        : [12, 'Enemy Type']
             enemy_type_5         : *STTENTRY1
             enemy_type_5?        : [12, 'Enemy Type']
             enemy_type_6         : *STTENTRY1
             enemy_type_6?        : [12, 'Enemy Type']
             enemy_type_7         : *STTENTRY1
             enemy_type_7?        : [12, 'Enemy Type']
             enemy_type_8         : *STTENTRY1
             enemy_type_8?        : [12, 'Enemy Type']
             elemental_1          : *STTENTRY1
             elemental_1?         : [11, 'Elemental ']
             elemental_2          : *STTENTRY1
             elemental_2?         : [11, 'Elemental ']
             elemental_3          : *STTENTRY1
             elemental_3?         : [11, 'Elemental ']
             elemental_4          : *STTENTRY1
             elemental_4?         : [11, 'Elemental ']
             elemental_5          : *STTENTRY1
             elemental_5?         : [11, 'Elemental ']
             elemental_6          : *STTENTRY1
             elemental_6?         : [11, 'Elemental ']
             elemental_7          : *STTENTRY1
             elemental_7?         : [11, 'Elemental ']
             elemental_8          : *STTENTRY1
             elemental_8?         : [11, 'Elemental ']
             armor_1              : *STTENTRY1
             armor_1?             : [7, 'Armor 1']
             armor_2              : *STTENTRY1
             armor_2?             : [7, 'Armor 2']
             armor_3              : *STTENTRY1
             armor_3?             : [7, 'Armor 3']
             armor_4              : *STTENTRY1
             armor_4?             : [7, 'Armor 4']
             spell_skill          : *STTENTRY1
             spell_skill?         : [11, 'Spell Skil']
             spell_block          : *STTENTRY1
             spell_block?         : [11, 'Spell Bloc']
             spell_cost_pc        : *STTENTRY1
             spell_cost_pc?       : [12, 'Spell cost']
             money                : *STTENTRY1
             money?               : [5, 'Money']
             experience           : *STTENTRY1
             experience?          : [10, 'Experience']
             item                 : *STTENTRY1
             item?                : [4, 'Item']
             done                 : *STTENTRY1
             done?                : [4, 'DONE']
             autosort             : *STTENTRY1
             autosort?            : [8, 'AUTOSORT']
             trash                : *STTENTRY1
             trash?               : [5, 'TRASH']
             weapon               : *STTENTRY1
             weapon?              : [6, 'Weapon']
             -remove-             : *STTENTRY1
             -remove-?            : [8, '-REMOVE-']
             -exit-               : *STTENTRY1
             -exit-?              : [6, '-EXIT-']
             discard              : *STTENTRY1
             discard?             : [7, 'Discard']
             cannot               : *STTENTRY1
             cannot?              : [6, 'Cannot']
             level                : *STTENTRY1
             level?               : [5, 'Level']
             yes                  : *STTENTRY1
             yes?                 : [3, 'Yes']
             no                   : *STTENTRY1
             no?                  : [2, 'No']
             exit                 : *STTENTRY1
             exit?                : [4, 'EXIT']
             for_next             : *STTENTRY1
             for_next?            : [8, 'for next']
             remove               : *STTENTRY1
             remove?              : [6, 'REMOVE']
             pay                  : *STTENTRY1
             pay?                 : [3, 'Pay']
             cancel               : *STTENTRY1
             cancel?              : [6, 'Cancel']
             cancel2              : *STTENTRY1
             cancel2?             : [6, 'CANCEL']
             new_game             : *STTENTRY1
             new_game?            : [8, 'NEW GAME']
             exit2                : *STTENTRY1
             exit2?               : [4, 'EXIT']
             pause                : *STTENTRY1
             pause?               : [5, 'PAUSE']
             quit_playing_        : *STTENTRY2
             quit_playing_?       : [13, 'Quit Playi', 13, 'ng?']
             yes2                 : *STTENTRY1
             yes2?                : [3, 'Yes']
             no2                  : *STTENTRY1
             no2?                 : [2, 'No']
             cancel3              : *STTENTRY1
             cancel3?             : [6, 'CANCEL']
             items                : *STTENTRY1
             items?               : [5, 'Items']
             spells               : *STTENTRY1
             spells?              : [6, 'Spells']
             status               : *STTENTRY1
             status?              : [6, 'Status']
             equip                : *STTENTRY1
             equip?               : [5, 'Equip']
             order                : *STTENTRY1
             order?               : [5, 'Order']
             team                 : *STTENTRY1
             team?                : [4, 'Team']
             save                 : *STTENTRY1
             save?                : [4, 'Save']
             quit                 : *STTENTRY1
             quit?                : [4, 'Quit']
             map                  : *STTENTRY1
             map?                 : [3, 'Map']
             volume               : *STTENTRY1
             volume?              : [6, 'Volume']
             buy                  : *STTENTRY1
             buy?                 : [3, 'Buy']
             sell                 : *STTENTRY1
             sell?                : [4, 'Sell']
             inn                  : *STTENTRY1
             inn?                 : [3, 'Inn']
             hire                 : *STTENTRY1
             hire?                : [4, 'Hire']
             exit3                : *STTENTRY1
             exit3?               : [4, 'Exit']
             cannot_sell          : *STTENTRY2
             cannot_sell?         : [11, 'CANNOT SEL', 11, 'L']
             worth                : *STTENTRY2
             worth?               : [5, 'Worth', 5, '']
             trade_for            : *STTENTRY2
             trade_for?           : [9, 'Trade for', 9, '']
             and_a                : *STTENTRY1
             and_a?               : [5, 'and a']
             worth_nothing        : *STTENTRY2
             worth_nothing?       : [13, 'Worth Noth', 13, 'ing']
             sold                 : *STTENTRY1
             sold?                : [4, 'Sold']
             trade_for2           : *STTENTRY2
             trade_for2?          : [9, 'Trade for', 9, '']
             joins_for            : *STTENTRY2
             joins_for?           : [9, 'Joins for', 9, '']
             cannot_afford        : *STTENTRY2
             cannot_afford?       : [13, 'Cannot Aff', 13, 'ord']
             cannot_hire          : *STTENTRY2
             cannot_hire?         : [11, 'Cannot Hir', 11, 'e']
             purchased            : *STTENTRY2
             purchased?           : [9, 'Purchased', 9, '']
             joined_              : *STTENTRY2
             joined_?             : [7, 'Joined!', 7, '']
             in_stock             : *STTENTRY2
             in_stock?            : [8, 'in stock', 8, '']
             equip_               : *STTENTRY1
             equip_?              : [6, 'Equip:']
             no_room_in_party     : *STTENTRY2
             no_room_in_party?    : [16, 'No Room In', 16, ' Party']
             replace_old_data_    : *STTENTRY2
             replace_old_data_?   : [17, 'Replace Ol', 17, 'd Data?']
             who_s_status_        : *STTENTRY2
             who_s_status_?       : [13, "Who's Stat", 13, 'us?']
             who_s_spells_        : *STTENTRY2
             who_s_spells_?       : [13, "Who's Spel", 13, 'ls?']
             equip_who_           : *STTENTRY2
             equip_who_?          : [10, 'Equip Who?', 10, '']
             nothing              : *STTENTRY1
             nothing?             : [7, 'Nothing']
             has_nothing          : *STTENTRY3
             has_nothing?         : [11, 'Has Nothin', 11, 'g', 11, '']
             cannot_steal         : *STTENTRY3
             cannot_steal?        : [12, 'Cannot Ste', 12, 'al', 12, '']
             stole                : *STTENTRY3
             stole?               : [5, 'Stole', 5, '', 5, '']
             miss                 : *STTENTRY2
             miss?                : [4, 'miss', 4, '']
             fail                 : *STTENTRY2
             fail?                : [4, 'fail', 4, '']
             learned              : *STTENTRY1
             learned?             : [7, 'learned']
             found                : *STTENTRY1
             found?               : [5, 'Found']
             gained               : *STTENTRY1
             gained?              : [6, 'Gained']
             weak_to              : *STTENTRY1
             weak_to?             : [7, 'Weak to']
             strong_to            : *STTENTRY1
             strong_to?           : [9, 'Strong to']
             absorbs              : *STTENTRY1
             absorbs?             : [7, 'Absorbs']
             no_elemental_effects : *STTENTRY3
             no_elemental_effects? : [20, 'No Element', 20, 'al Effects', 20, '']
             has_no_spells        : *STTENTRY2
             has_no_spells?       : [13, 'has no spe', 13, 'lls']
             which_hero_          : *STTENTRY2
             which_hero_?         : [11, 'Which Hero', 11, '?']
             name_the_hero        : *STTENTRY2
             name_the_hero?       : [13, 'Name the H', 13, 'ero']
             found_a              : *STTENTRY2
             found_a?             : [7, 'Found a', 7, '']
             found2               : *STTENTRY2
             found2?              : [5, 'Found', 5, '']
             the_inn_costs        : *STTENTRY2
             the_inn_costs?       : [13, 'THE INN CO', 13, 'STS']
             you_have             : *STTENTRY2
             you_have?            : [8, 'You have', 8, '']
             cannot_run_          : *STTENTRY2
             cannot_run_?         : [11, 'CANNOT RUN', 11, '!']
             level_up_for         : *STTENTRY2
             level_up_for?        : [12, 'Level up f', 12, 'or']
             levels_for           : *STTENTRY2
             levels_for?          : [10, 'levels for', 10, '']
             and                  : *STTENTRY1
             and?                 : [3, 'and']
             day                  : *STTENTRY1
             day?                 : [3, 'day']
             days                 : *STTENTRY1
             days?                : [4, 'days']
             hour                 : *STTENTRY1
             hour?                : [4, 'hour']
             hours                : *STTENTRY1
             hours?               : [5, 'hours']
             minute               : *STTENTRY1
             minute?              : [6, 'minute']
             minutes              : *STTENTRY1
             minutes?             : [7, 'minutes']
             level_mp             : *STTENTRY2
             level_mp?            : [8, 'Level MP', 8, '']

til :
   << : *mxs
   attrname : tileset
   dataattrs:
      defpass: defpass.bin

tmn :
   << : [*CLASS_DTYPE, *RPGOWNED]
   attrname : tagname
   methods:
      get (self, index): |
          if index == 0:
              return '<Always False>'
          elif index == 1:
              return '<Always True>'
          elif index > len(self) + 1:
              return '<Unnamed>'
          return getstr (self[index - 2])
      set (self, index, value): |
          if index == 0 or index == 1:
              raise ValueError ("can't set tag %d description!" % index)
          setstr (self[index - 2], value)
   fields : length data
   flags : AUTOEXPAND
   dtype :
      - -
         dtypes :
            length : [uint8, [0,10], 0]
            data : [S10, no, '']
