#!/usr/bin/env python3
#coding=utf8

from unittest import TestCase
import nose
from oktest import ok
import os
import io
import nohrio.nohrio2 as nohrio
from nohrio.dtypes.tag import TagCheckClass, _FIXEDVALUES



# XXX move this into a shared test resources module
def save_to_bytes(obj, *args, **kwargs):
    """Return the bytes generated by obj.save(bytesio, *args,**kwargs)"""
    output = io.BytesIO()
    obj.save(output, *args, **kwargs)
    return output.getvalue()

def load_from_bytes(cls, _bytes, *args, **kwargs):
    """Return the object generated by cls.load(bytesio, *args,**kwargs)"""
    input = io.BytesIO(_bytes)
    return cls.load(input, *args, **kwargs)

class TestTagCheck(TestCase):
    # XXX for now, we don't try to equip self to a real rpg object properly.
    class rpg(object):
        filename = 'RPG'
    # XXX hack
    Check = TagCheckClass(rpg)
    def setUp (self):
        pass
    def tearDown (self):
        pass

    def testConflictingParams (self):
        """TagCheck(>1 of value|on|off) raises ValueError"""
        ok(lambda: self.Check(value = 1000, on = 1000)).raises(ValueError)
        ok(lambda: self.Check(on = 1000, off = 1000)).raises(ValueError)
        ok(lambda: self.Check(value = 1000, off = 1000)).raises(ValueError)
        ok(lambda: self.Check(value = 1000, on = 1000, off = 1000)).raises(ValueError)

    def testValue (self):
        """TagCheck(value=x) == x"""
        ok(int(self.Check(1000))) == 1000

    def testOn (self):
        """TagCheck(on=x) == x"""
        ok(int(self.Check(on = 1000))) == 1000

    def testOff(self):
        """TagCheck(off=x) == -x"""
        ok(int(self.Check(off = 1000))) == -1000

    def testBadOnOff(self):
        """Negative values accepted for value and rejected(ValueError) for on|off"""
        ok(lambda: self.Check(off = -1000)).raises(ValueError)
        ok(lambda: self.Check(on = -1000)).raises(ValueError)
        ok(lambda: self.Check(value = -1000)).not_raise(ValueError)

    def testDifferentTypes(self):
        """TagCheck(x) != int(x)"""
        # TagCheck incorporates extra data which means this comparison should fail
        ok(self.Check(1000)) != 1000

    def testBadCompare(self):
        """TagCheck(x) (<|<=|>|>=) int(x) raises TypeError"""
        ok(lambda: self.Check(1000) < 1001).raises(TypeError)
        ok(lambda: self.Check(1000) <= 1000).raises(TypeError)
        ok(lambda: self.Check(1000) > 999).raises(TypeError)
        ok(lambda: self.Check(1000) >= 1000).raises(TypeError)

    def testEqual (self):
        """TagCheck(x) == Tagcheck(x)"""
        ok(self.Check(1000)) == self.Check(1000)

    def testStr(self):
        """TagCheck() str() looks normal"""
        ok(str(self.Check(1000))) == "RPG->TagCheck(on = 1000)"
        ok(str(self.Check(on = 1000))) == "RPG->TagCheck(on = 1000)"
        ok(str(self.Check(off = 1000))) == "RPG->TagCheck(off = 1000)"
        ok(str(self.Check(-1))) == "RPG->TagCheck(off = 1 (Never))"
        ok(str(self.Check(0))) == "RPG->TagCheck(on = 0 (Never))"
        ok(str(self.Check(1))) == "RPG->TagCheck(on = 1 (Always))"

    def testRepr(self):
        """TagCheck() repr() looks normal"""
        ok(repr(self.Check(1000))) == "TagCheckClass(<class 'test_tag.rpg'>)(on = 1000)"
        ok(repr(self.Check(on = 1000))) == "TagCheckClass(<class 'test_tag.rpg'>)(on = 1000)"
        ok(repr(self.Check(off = 1000))) == "TagCheckClass(<class 'test_tag.rpg'>)(off = 1000)"
        ok(repr(self.Check(0))) == "TagCheckClass(<class 'test_tag.rpg'>)(on = 0)"
        ok(repr(self.Check(1))) == "TagCheckClass(<class 'test_tag.rpg'>)(on = 1)"

    def testSave(self):
        """TagCheck().save() outputs in correct binary format"""
        ok(save_to_bytes(self.Check(1000))) == b'\xe8\x03'
        ok(save_to_bytes(self.Check(-1000))) == b'\x18\xfc'
        ok(save_to_bytes(self.Check(0))) == b'\x00\x00'

    def testLoad(self):
        """TagCheck.load() parses correct binary format appropriately"""
        # hack. I haven't decided how the class creator should be accessed yet
        cls = self.Check
        print (cls)
        ok(load_from_bytes(cls, b'\xe8\x03')) == self.Check(1000)
        ok(load_from_bytes(cls, b'\x18\xfc')) == self.Check(-1000)
        ok(load_from_bytes(cls, b'\x00\x00')) == self.Check(0)

    def testmatch(self):
        """TagCheck().match returns False for off tests and True for on tests"""
        for i in range(100):
            ok(self.Check(i).match) == True
            if i != 0:
                ok(self.Check(-i).match) == False

    # XXX tagindex should be a derived attribute. It's just more readable and typeable.

    def testTagIndex(self):
        """TagCheck().index returns sensible values"""
        for i in range(100):
            ok(self.Check(i).index) == i
            ok(self.Check(-i).index) == i

    def testUseIndex(self):
        """sequence[TagCheck().index] == TagCheck().match works"""
        #        0F    1F    2     3      4     5     6
        seq = (False, True, True, False, True, True, False)
        for v in (1, 5, -3, 2, 4, -6):
            check = self.Check(v)
            ok(seq[check.index]) == check.match
            ok(seq[check.index]) != (not check.match)

    def testNoLoadInto(self):
        """TagCheck().reloadfrom() raises NotImplementedError"""
        ok(lambda :self.Check(45).reloadfrom('/tmp/foo')).raises(NotImplementedError)

    #isfixed = tagcheck.tagindex() < 2


if __name__ == "__main__":
    nose.main(defaultTest='test_tag.py')
